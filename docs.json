[{"name":"RecordFieldHelper.GenerateUsed","comment":"\n\n@docs rule, Config\n\n\n# lens generators\n\n\n## working out of the box\n\n@docs accessors, monocle, fields, zipper, accessorsBChiquet\n\n\n## custom\n\n@docs FieldLensGenerator, FieldLensDeclaration, functionsForField, getSetRecordForField, withDocumentation, withName\n\n","unions":[],"aliases":[{"name":"Config","comment":" The [rule](#rule)'s configuration.\n\n  - `generate`: What kind of lens to generate:\n      - [`elm-accessors`](#accessors),\n      - [`elm-fields`](#fields),\n      - [`elm-monocle`](#monocle),\n      - [`zipper`](#zipper) or\n      - [`updateField`](#update), [`setField`](#set)\n      - [a custom one](#FieldLensGenerator).\n\n  - `generateIn`: The module where all field lenses will be generated in\n\n    read `( \"Module\", [ \"Name\" ] )` as `Module.Name`\n\n","args":[],"type":"{ generator : RecordFieldHelper.GenerateUsed.FieldLensGenerator, generateIn : ( String.String, List.List String.String ) }"},{"name":"FieldLensDeclaration","comment":" All the components to build a field lens declaration:\n\n    {-| [documentation]\n    -}\n    [name] : [annotation]\n    [name] =\n        [implementation]\n\nYou can customize existing `FieldLensDeclaration`s with [`withDocumentation`](#withDocumentation) and [`withName`](#withName)\nor create custom lens ([`functionsForField`](#functionsForField) and [`getSetRecordForField`](#getSetRecordForField) can be helpful).\n\n    customLensDeclaration { fieldName } =\n        { documentation =\n            emptyDocComment\n                |> markdown\n                    (\"`CustomLens` for the field `.\" ++ fieldName ++ \"`.\")\n                |> Just\n        , name = fieldName\n        , annotation =\n            typed \"CustomLens\"\n                [ extRecordAnn \"record\"\n                    [ ( fieldName, typeVar fieldName ) ]\n                , typeVar fieldName\n                ]\n                |> Just\n        , implementation =\n            let\n                { access, set } =\n                    functionsForField fieldName\n            in\n            fqConstruct [ \"CustomLens\" ] \"create\" [ access, at ]\n        }\n\n","args":[],"type":"{ documentation : Maybe.Maybe (Elm.CodeGen.Comment Elm.CodeGen.DocComment), name : String.String, annotation : Maybe.Maybe Elm.CodeGen.TypeAnnotation, implementation : Elm.CodeGen.Expression }"},{"name":"FieldLensGenerator","comment":" How to generate a [`FieldLensDeclaration`](#FieldLensDeclaration) plus the necessary imports.\n\nOut of the box there are lenses for\n\n  - [`erlandsona/elm-accessors`](#accessors)\n  - [`elm-fields`](#fields)\n  - [`elm-monocle`](#monocle)\n  - [`zipper`](#zipper)\n  - [`bChiquet/elm-accessors`](#accessorsBChiquet)\n\nYou can also create a custom one with the help of [the-sett's elm-syntax-dsl](https://package.elm-lang.org/packages/the-sett/elm-syntax-dsl/latest):\n\n    customLens : FieldLensGenerator\n    customLens =\n        { imports =\n            [ importStmt [ \"CustomLens\" ]\n                Nothing\n                (exposeExplicit\n                    [ typeOrAliasExpose \"CustomLens\" ]\n                    |> Just\n                )\n            ]\n        , declaration =\n            \\{ fieldName } ->\n                { documentation =\n                    emptyDocComment\n                        |> markdown\n                            (\"`CustomLens` for the field `.\" ++ fieldName ++ \"`.\")\n                        |> Just\n                , name = fieldName\n                , annotation =\n                    typed \"CustomLens\"\n                        [ extRecordAnn \"record\"\n                            [ ( fieldName, typeVar fieldName ) ]\n                        , typeVar fieldName\n                        ]\n                        |> Just\n                , implementation =\n                    let\n                        { access, set } =\n                            functionsForField fieldName\n                    in\n                    fqConstruct [ \"CustomLens\" ] \"create\" [ access, at ]\n                }\n        }\n\n","args":[],"type":"{ imports : List.List Elm.CodeGen.Import, declaration : { fieldName : String.String } -> RecordFieldHelper.GenerateUsed.FieldLensDeclaration }"}],"values":[{"name":"accessors","comment":" [`FieldLensGenerator`](#FieldLensGenerator)\nfor named [`erlandsona/elm-accessors`](https://dark.elm.dmy.fr/packages/erlandsona/elm-accessors/latest/)\nin the form\n\n    import Accessors exposing (Lens, makeOneToOne_)\n\n    score : Lens { record | score : score } transformed score wrap\n    score =\n        makeOneToOne_ \".score\" .score (\\alter record -> { record | score = record.score |> alter })\n\n","type":"RecordFieldHelper.GenerateUsed.FieldLensGenerator"},{"name":"accessorsBChiquet","comment":" [`FieldLensGenerator`](#FieldLensGenerator) for [`bChiquet/elm-accessors`](https://package.elm-lang.org/packages/bChiquet/elm-accessors/latest) in the form\n\n    import Accessors exposing (Relation, makeOneToOne)\n\n    score : Relation score transformed wrap -> Relation { record | score : score } transformed wrap\n    score =\n        makeOneToOne .score (\\alter record -> { record | score = record.score |> alter })\n\n[`accessors`](#accessors) generates for [`erlandsona/elm-accessors`](https://dark.elm.dmy.fr/packages/erlandsona/elm-accessors/latest/) which adds names.\n\n","type":"RecordFieldHelper.GenerateUsed.FieldLensGenerator"},{"name":"fields","comment":" [`FieldLensGenerator`](#FieldLensGenerator) for [sjorn3's elm-fields](https://package.elm-lang.org/packages/sjorn3/elm-fields/latest/) in the form\n\n    score :\n        { get : { record0 | score : score } -> score\n        , set : score -> { record1 | score : score } -> { record1 | score : score }\n        }\n    score =\n        { get = .score, set = \\replacement record -> { record | score = replacement } }\n\n","type":"RecordFieldHelper.GenerateUsed.FieldLensGenerator"},{"name":"functionsForField","comment":" access, set and update functions for a given record field.\n\n    functionsForField \"score\"\n\n    -->\n    { access = accessFun (\".\" ++ fieldName)\n    , set =\n        lambda\n            [ varPattern \"replacement\"\n            , varPattern \"record\"\n            ]\n            (update \"record\"\n                [ ( fieldName\n                  , val \"replacement\"\n                  )\n                ]\n            )\n    , update =\n        lambda\n            [ varPattern \"alter\"\n            , varPattern \"record\"\n            ]\n            (update \"record\"\n                [ ( fieldName\n                  , applyBinOp\n                        (access (val \"record\") fieldName)\n                        piper\n                        (fun \"alter\")\n                  )\n                ]\n            )\n    }\n\n","type":"String.String -> { access : Elm.CodeGen.Expression, set : Elm.CodeGen.Expression, update : Elm.CodeGen.Expression }"},{"name":"getSetRecordForField","comment":" Generate a field lens implementation in the form\n\n    { get = .score, set = \\replacement record -> { record | score = replacement } }\n\nThis is equivalent to\n\n    let\n        { access, set } =\n            functionsForField fieldName\n    in\n    record [ ( \"get\", access ), ( \"set\", set ) ]\n\n","type":"String.String -> Elm.CodeGen.Expression"},{"name":"monocle","comment":" [`FieldLensGenerator`](#FieldLensGenerator) for [arturopala's elm-monocle](https://package.elm-lang.org/packages/arturopala/elm-monocle/latest) in the form\n\n    import Monocle.Lens exposing (Lens)\n\n    score : Lens { record | score : score } score\n    score =\n        { get = .score, set = \\replacement record -> { record | score = replacement } }\n\n","type":"RecordFieldHelper.GenerateUsed.FieldLensGenerator"},{"name":"rule","comment":" Automatically generates used record field helpers that don't exist yet.\n\nExamples are\n\n  - [`erlandsona/elm-accessors`](https://package.elm-lang.org/packages/erlandsona/elm-accessors/latest/)\n  - [`sjorn3/elm-fields`](https://package.elm-lang.org/packages/sjorn3/elm-fields/latest/)\n  - [`arturopala/elm-monocle`](https://package.elm-lang.org/packages/arturopala/elm-monocle/latest)\n  - [`zh5/zipper`](https://package.elm-lang.org/packages/z5h/zipper/latest/)\n  - [`bChiquet/elm-accessors`](https://package.elm-lang.org/packages/bChiquet/elm-accessors/latest)\n\n```\nconfig =\n    [ RecordFieldHelper.GenerateUsed.rule\n        { generator = RecordFieldHelper.GenerateUsed.accessors\n        , generateIn = ( \"Accessors\", [ \"Library\", \"Fields\" ] )\n        }\n    ]\n```\n\n  - `generator`: What kind of lens to generate:\n      - [`elm-accessors`](#accessors),\n      - [`elm-fields`](#fields),\n      - [`elm-monocle`](#monocle),\n      - [`zipper`](#zipper) or\n      - [a custom one](#FieldLensGenerator).\n\n  - `generateIn`: The module where all field lenses will be generated in\n\n    understand `( \"Accessors\", [ \"Library\", \"Fields\" ] )` as `Accessors.Library.Fields`\n\n\n## Example\n\n    module SomeModule exposing (scoreAPoint)\n\n    import Accessors.Library.Fields as Field\n\n    scoreAPoint =\n        Accessors.over Field.score (\\score -> score + 1)\n\n\n### Fail\n\n    module Accessors.Library.Fields exposing (name)\n\n    ...\n\n\n### Success\n\n    module Accessors.Library.Fields exposing (score)\n\n    ...\n\n","type":"RecordFieldHelper.GenerateUsed.Config -> Review.Rule.Rule"},{"name":"withDocumentation","comment":" The provided [`FieldLensGenerator`](#FieldLensGenerator)s in this package have no documentation comment.\n\nYou can generate your own documentation, though:\n\n    accessorsWithDocumentation { fieldName } =\n        accessors { fieldName = fieldName }\n            |> withDocumentation\n                (emptyDocComment\n                    |> markdown\n                        (\"Accessor for the field `.\" ++ fieldName ++ \"`.\")\n                )\n\n","type":"Elm.CodeGen.Comment Elm.CodeGen.DocComment -> RecordFieldHelper.GenerateUsed.FieldLensDeclaration -> RecordFieldHelper.GenerateUsed.FieldLensDeclaration"},{"name":"withName","comment":" Use a different name for the generated lens.\n\n    accessorsWithFieldSuffix { fieldName } =\n        accessors { fieldName = fieldName }\n            |> withName (fieldName ++ \"Field\")\n\n","type":"String.String -> RecordFieldHelper.GenerateUsed.FieldLensDeclaration -> RecordFieldHelper.GenerateUsed.FieldLensDeclaration"},{"name":"zipper","comment":" [`FieldLensGenerator`](#FieldLensGenerator) for [z5h's zipper](https://package.elm-lang.org/packages/z5h/zipper/latest/) in the form\n\n    import Zipper exposing (Zipper, into)\n\n    intoScore : Zipper { record | score : score } root -> Zipper score root\n    intoScore =\n        into .score (\\replacement record -> { record | score = replacement })\n\n","type":"RecordFieldHelper.GenerateUsed.FieldLensGenerator"}],"binops":[]},{"name":"VariantHelper.GenerateUsed","comment":" Generate helpers for variant values\n\n@docs rule\n\n\n## build\n\n@docs VariantHelperBuild\n@docs accessors, accessorsBChiquet\n@docs documented, annotated, importsAdd\n@docs variantInMultiple, variantOnly\n@docs ValuesCombined, valuesTupleNest, valuesRecord\n@docs variantPattern\n\n\n## name\n\n@docs VariantHelperNameConfig, onVariant, variant\n\n","unions":[],"aliases":[{"name":"ValuesCombined","comment":" Representation of values as one whole, for example\n\n  - [`valuesRecord`](#valuesRecord): `{ value0 = ..., value1 = ..., value2 = ... }`\n  - [`valuesTupleNest`](#valuesTupleNest): `( ..., ( ..., ... ) )`\n  - [`Toop.T3 ... ... ...`](https://dark.elm.dmy.fr/packages/bburdette/toop/latest/)\n  - ...\n\n","args":[],"type":"{ name : String.String, values : List.List Elm.CodeGen.TypeAnnotation } -> { typeInOne : Elm.CodeGen.TypeAnnotation, inOne : String.String -> Elm.CodeGen.Expression, patternInOne : String.String -> Elm.CodeGen.Pattern, alter : Elm.CodeGen.Expression }"},{"name":"VariantHelperBuild","comment":" Configure\nhow to generate a variant helper declaration\nplus the necessary `import`s.\n\nOut of the box, there are\n\n  - [`accessors`](#accessors)\n  - [`accessorsBChiquet`](#accessorsBChiquet)\n\nCustomize with\n\n  - [`documented`](#documented)\n  - [`annotated`](#annotated)\n  - [`importsAdd`](#importsAdd)\n\nCreate a custom helper generator (or just parts for replacement) with\n\n  - [`the-sett/elm-syntax-dsl`](https://package.elm-lang.org/packages/the-sett/elm-syntax-dsl/latest)\n  - [`variantInMultiple`](#variantInMultiple), [`variantOnly`](#variantOnly)\n  - [`valuesTupleNest`](#valuesTupleNest) , [`valuesRecord`](#valuesRecord)\n  - [`variantPattern`](#variantPattern)\n\nYou can use the source code of [`accessors`](#accessors) & co. as a starting point.\n\n","args":[],"type":"{ variantModule : String.String, typeName : String.String, typeParameters : List.List String.String, variantName : String.String, variantValues : List.List Elm.CodeGen.TypeAnnotation, otherVariants : Dict.Dict String.String { valueCount : Basics.Int } } -> { imports : List.List Elm.CodeGen.Import, documentation : Maybe.Maybe (Elm.CodeGen.Comment Elm.CodeGen.DocComment), annotation : Maybe.Maybe Elm.CodeGen.TypeAnnotation, implementation : Elm.CodeGen.Expression }"},{"name":"VariantHelperNameConfig","comment":" How to derive helper name â†” variant name.\n\nOut of the box, there are\n\n  - [`onVariant`](onVariant)\n  - [`variant`](#variant)\n\nYou can also create a custom [`VariantHelperNameConfig`](#VariantHelperNameConfig):\n\n    import Parser\n\n    { build = \\{ variantName } -> variantName ++ \"Variant\"\n    , parser =\n        Parser.map (\\variantName -> { variantName = variantName })\n            (Parser.loop \"\"\n                (\\beforeSuffixFoFar ->\n                    Parser.oneOf\n                        [ Parser.token \"Variant\"\n                            |. Parser.end\n                            |> Parser.map (\\() -> Parser.Done beforeSuffixFoFar)\n                        , Parser.chompIf (\\_ -> True)\n                            |> Parser.getChompedString\n                            |> Parser.map\n                                (\\stillNotSuffix ->\n                                    Parser.Loop (beforeSuffixFoFar ++ stillNotSuffix)\n                                )\n                        ]\n                )\n            )\n    }\n\nIt's not half as daunting as it looks. If you feel motivated ðŸ‘€ â†“\n\n  - a [video guide \"Demystifying Parsers\" by Tereza Sokol](https://m.youtube.com/watch?v=M9ulswr1z0E)\n  - an [\"Introduction to the elm/parser package\" by Alex Korban](https://korban.net/posts/elm/2018-09-07-introduction-elm-parser/)\n  - [the `elm/parser` package](https://dark.elm.dmy.fr/packages/elm/parser/latest/)\n\nMini tip: testing is always a good idea for `Parser`s\n\nDon't worry about the casing of the results.\nThey will be automatically be corrected when passed to [`rule`](#rule).\n\nIn the future,\n[`elm-morph`](https://github.com/lue-bird/elm-morph)\nwill allow creating builders and parsers in one go,\nmaking this easier.\n\n","args":[],"type":"RecordWithoutConstructorFunction.RecordWithoutConstructorFunction { parser : Parser.Parser { variantName : String.String }, build : { variantName : String.String } -> String.String }"}],"values":[{"name":"accessors","comment":" [`Build`](#Build)\nof named [`erlandsona/elm-accessors`](https://dark.elm.dmy.fr/packages/erlandsona/elm-accessors/latest/)\nwhich with\n\n    { build =\n        VariantHelper.GenerateUsed.accessors\n            { valuesCombined = VariantHelper.GenerateUsed.valuesTupleNest }\n    , nameInModuleInternal = VariantHelper.GenerateUsed.onVariant\n    , nameInModuleExternal = VariantHelper.GenerateUsed.variant\n    , generationModuleIsVariantModuleDotSuffix = \"On\"\n    }\n\nand\n\n    module Data exposing (Data(..))\n\n    type Data a b c d\n        = Some a b c d\n        | None\n\ngenerates\n\n    module Data.On exposing (some)\n\n    import Accessors exposing (makeOneToN_)\n    import Data exposing (Data(..))\n\n    {-| Accessor prism for the variant `Data.Some` of the `type Data`.\n    -}\n    some :\n        Relation ( a, ( b, ( c, d ) ) ) reachable wrap\n        -> Relation (Data a b c d) reachable (Maybe wrap)\n    some =\n        makeOneToN_\n            \"Data.Some\"\n            (\\valuesAlter variantType ->\n                case variantType of\n                    Some value0 value1 value2 value3 ->\n                        ( value0, ( value1, ( value2, value3 ) ) ) |> valuesAlter |> Just\n\n                    _ ->\n                        Nothing\n            )\n            (\\valuesAlter variantType ->\n                case variantType of\n                    Some value0 value1 value2 value3 ->\n                        let\n                            ( alteredValue0, ( alteredValue1, ( alteredValue2, alteredValue3 ) ) ) =\n                                ( value0, ( value1, ( value2, value3 ) ) ) |> valuesAlter\n                        in\n                        Some alteredValue0 alteredValue1 alteredValue2 alteredValue3\n\n                    other ->\n                        other\n            )\n\n","type":"{ valuesCombined : VariantHelper.GenerateUsed.ValuesCombined } -> VariantHelper.GenerateUsed.VariantHelperBuild"},{"name":"accessorsBChiquet","comment":" [`Build`](#Build)\nof unnamed [bChiquet/elm-accessors](https://dark.elm.dmy.fr/packages/bChiquet/elm-accessors/latest/)\nwhich with\n\n    { build =\n        VariantHelper.GenerateUsed.accessorsBChiquet\n            { valuesCombined = VariantHelper.GenerateUsed.valuesTupleNest }\n    , name = VariantHelper.GenerateUsed.variant\n    , generationModuleIsVariantModuleDotSuffix = \"On\"\n    }\n\nand\n\n    module Data exposing (Data(..))\n\n    type Data a b c d\n        = Some a b c d\n        | None\n\ngenerates\n\n    module Data.On exposing (some)\n\n    import Accessors exposing (Lens, Relation, makeOneToN_)\n    import Data exposing (Data(..))\n\n    {-| Accessor prism for the variant `Data.Some` of the `type Data`.\n    -}\n    some :\n        Relation ( a, ( b, ( c, d ) ) ) reachable wrap\n        -> Relation (Data a b c d) reachable (Maybe wrap)\n    some =\n        makeOneToN\n            (\\valuesAlter variantType ->\n                case variantType of\n                    Some value0 value1 value2 value3 ->\n                        ( value0, ( value1, ( value2, value3 ) ) ) |> valuesAlter |> Just\n\n                    _ ->\n                        Nothing\n            )\n            (\\valuesAlter variantType ->\n                case variantType of\n                    Some value0 value1 value2 value3 ->\n                        let\n                            ( alteredValue0, ( alteredValue1, ( alteredValue2, alteredValue3 ) ) ) =\n                                ( value0, ( value1, ( value2, value3 ) ) ) |> valuesAlter\n                        in\n                        Some alteredValue0 alteredValue1 alteredValue2 alteredValue3\n\n                    other ->\n                        other\n            )\n\n","type":"{ valuesCombined : VariantHelper.GenerateUsed.ValuesCombined } -> VariantHelper.GenerateUsed.VariantHelperBuild"},{"name":"annotated","comment":" [Build](#Build) a different type annotation:\n\n    import Hand exposing (Hand(..))\n    import Stack\n\n    accessorsAnnotatedOption : Build\n    accessorsAnnotatedOption info =\n        accessors\n            { valuesCombined = valuesRecord }\n            info\n            |> annotated\n                (typed \"Option\"\n                    [ CodeGen.typed info.typeName\n                        (info.typeParameters |> List.map CodeGen.typeVar)\n                    , case variantValues |> Stack.fromList of\n                        Empty _ ->\n                            CodeGen.unitAnn\n\n                        Filled stacked ->\n                            Filled stacked\n                                |> Stack.reverse\n                                |> Stack.fold (\\value soFar -> CodeGen.tupleAnn [ value, soFar ])\n                    , CodeGen.typeVar \"reachable\"\n                    , CodeGen.typeVar \"wrap\"\n                    ]\n                )\n            |> importsAdd\n                [ impostStmt [ \"Accessors\" ]\n                    Nothing\n                    ([ \"Option\" |> typeOrAliasExpose ] |> exposingExplicit |> Just)\n                ]\n\nMake sure to [`importsAdd`](#importsAdd).\n\n","type":"Elm.CodeGen.TypeAnnotation -> { declaration | annotation : Maybe.Maybe Elm.CodeGen.TypeAnnotation } -> { declaration | annotation : Maybe.Maybe Elm.CodeGen.TypeAnnotation }"},{"name":"documented","comment":" [Build](#VariantHelperBuild) a different documentation:\n\n    accessorsDocumentedCustom info =\n        accessors\n            { valuesCombined = valuesRecord }\n            info\n            |> documented\n                (emptyDocComment\n                    |> markdown\n                        (\"variant `\" ++ info.variantName ++ \"`: Accessor for the values.\")\n                )\n\n","type":"Elm.CodeGen.Comment Elm.CodeGen.DocComment -> { declaration | documentation : Maybe.Maybe (Elm.CodeGen.Comment Elm.CodeGen.DocComment) } -> { declaration | documentation : Maybe.Maybe (Elm.CodeGen.Comment Elm.CodeGen.DocComment) }"},{"name":"importsAdd","comment":" Supply additional `import`s required for generating the declaration.\n\n    accessorsAnnotatedOption : Build\n    accessorsAnnotatedOption info =\n        accessors info\n            |> annotated (typed \"Option\" [ ... ])\n            |> importsAdd\n                [ impostStmt [ \"Accessors\" ]\n                    Nothing\n                    ([ \"Option\" |> typeOrAliasExpose ] |> exposingExplicit |> Just)\n                ]\n\n","type":"List.List Elm.CodeGen.Import -> { declaration | imports : List.List Elm.CodeGen.Import } -> { declaration | imports : List.List Elm.CodeGen.Import }"},{"name":"onVariant","comment":" Handle helper names in the format `on<Variant>`.\nCheck out [`VariantHelperNameConfig`](#VariantHelperNameConfig) for all naming options.\n\n    import Parser\n    import VariantHelper.GenerateUsed\n\n    \"onSuccess\"\n        |> Parser.run VariantHelper.GenerateUsed.onVariant.parser\n    --> { variantName = \"Success\" }\n\n    { variantName = \"Success\" }\n        |> VariantHelper.GenerateUsed.onVariant.build\n    --> \"onSuccess\"\n\n","type":"VariantHelper.GenerateUsed.VariantHelperNameConfig"},{"name":"rule","comment":" Generate each helper for a variant of a `type`\nthat is called from your code but isn't already defined.\n\n    import Review.Rule as Rule exposing (Rule)\n    import VariantHelper.GenerateUsed\n\n    config : List Rule\n    config =\n        [ VariantHelper.GenerateUsed.rule ..config..\n        ]\n\n..config.. How to generate, where to generate:\n\n  - `build :`\n    a [`Build` function](#Build) like\n      - [`accessors`](#accessors)\n      - [`accessorsBChiquet`](#accessorsBChiquet)\n  - `name :`\n    a way to handle variant helper names like\n      - [`onVariant`](#onVariant)\n      - [`variant`](#variant)\n  - `generationModuleIsVariantModuleDotSuffix :`\n    a `.Suffix` to derive generation `module` names from variant `module` names\n\nThere's no configuration to automatically `import Variant.Module.Generation as Variant.Module`\nbecause [`import` aliases can't contain `.`](https://github.com/elm/compiler/issues/2260)\n\n\n### example `module Variant.Module.On exposing (some)`\n\n    { build =\n        VariantHelper.GenerateUsed.accessors\n            { valuesCombined = VariantHelper.GenerateUsed.valuesRecord }\n    , name = VariantHelper.GenerateUsed.variant\n    , generationModuleIsVariantModuleDotSuffix = \"On\"\n    }\n\n\n### example: `module Variant.Module.X exposing (onSome)`\n\n    { build =\n        VariantHelper.GenerateUsed.accessors\n            { valuesCombined = VariantHelper.GenerateUsed.valuesRecord }\n    , name = VariantHelper.GenerateUsed.onVariant\n    , generationModuleIsVariantModuleDotSuffix = \"X\"\n    }\n\n\n## use it\n\n... when you're using `elm-accessors` to mitigate\nboilerplate related to updating potentially deeply nested data.\n\n\n## don't use it\n\n... when you consider accessors the less readable/intuitive/simple/explicit alternative.\n\n","type":"{ nameInModuleInternal : VariantHelper.GenerateUsed.VariantHelperNameConfig, nameInModuleExternal : VariantHelper.GenerateUsed.VariantHelperNameConfig, build : VariantHelper.GenerateUsed.VariantHelperBuild, generationModuleIsVariantModuleDotSuffix : String.String } -> Review.Rule.Rule"},{"name":"valuesRecord","comment":" Helpers for a given variant to use with a custom implementation or [`variantOnly`](#variantOnly)/[`variantInMultiple`](#variantInMultiple).\n\nfor\n\n    type Data a b c d\n        = Some a b c d\n        | None\n\n\n#### `access`\n\n    { value0 = value0, value1 = value1, value2 = value2, value3 = value3 }\n\n\n#### `alter`\n\n    let\n        altered =\n            { value0 = value0, value1 = value1, value2 = value2, value3 = value3 }\n                |> valuesAlter\n    in\n    Some altered.value0 altered.value1 altered.value2 altered.value3\n\n\n#### `typeValues`\n\n    { value0 = a, value1 = b, value2 = c, value3 = d }\n\n","type":"{ name : String.String, values : List.List Elm.CodeGen.TypeAnnotation } -> { typeInOne : Elm.CodeGen.TypeAnnotation, inOne : String.String -> Elm.CodeGen.Expression, patternInOne : String.String -> Elm.CodeGen.Pattern, alter : Elm.CodeGen.Expression }"},{"name":"valuesTupleNest","comment":" Helpers for a given variant to use with a custom implementation or [`variantOnly`](#variantOnly)/[`variantInMultiple`](#variantInMultiple).\n\nfor\n\n    type Data a b c d\n        = Some a b c d\n        | None\n\n\n#### `typeInOne`\n\n    ( a, ( b, ( c, d ) ) )\n\n\n#### `inOne \"value\"`\n\n    ( value0, ( value1, ( value2, value3 ) ) )\n\n\n#### `patternInOne \"value\"`\n\n    ( value0, ( value1, ( value2, value3 ) ) )\n\n\n#### `alter`\n\n    let\n        ( alteredValue0, ( alteredValue1, ( alteredValue2, alteredValue3 ) ) ) =\n            ( value0, ( value1, ( value2, value3 ) ) ) |> valuesAlter\n    in\n    Some alteredValue0 alteredValue1 alteredValue2 alteredValue3\n\n","type":"{ name : String.String, values : List.List Elm.CodeGen.TypeAnnotation } -> { typeInOne : Elm.CodeGen.TypeAnnotation, inOne : String.String -> Elm.CodeGen.Expression, patternInOne : String.String -> Elm.CodeGen.Pattern, alter : Elm.CodeGen.Expression }"},{"name":"variant","comment":" Handle helper names in the format `<variant>`.\nCheck out [`VariantHelperNameConfig`](#VariantHelperNameConfig) for all naming options.\n\n    import Parser\n    import VariantHelper.GenerateUsed\n\n    \"success\"\n        |> Parser.run VariantHelper.GenerateUsed.helperNameAsVariant.parser\n    --> { variantName = \"Success\" }\n\n    { variantName = \"Success\" }\n        |> VariantHelper.GenerateUsed.helperNameAsVariant.build\n    --> \"success\"\n\n","type":"VariantHelper.GenerateUsed.VariantHelperNameConfig"},{"name":"variantInMultiple","comment":" Helpers for values of a given variant among >= 2.\n\nfor\n\n    type Data a b c d\n        = Some a b c d\n        | None\n\nwith\n\n    variantInMultiple valuesTupleNest\n\n\n#### `access`\n\n    \\valuesAlter variantType ->\n        case variantType of\n            Some value0 value1 value2 value3 ->\n                ( value0, ( value1, ( value2, value3 ) ) ) |> valuesAlter |> Just\n\n            _ ->\n                Nothing\n\n\n#### `alter`\n\n    \\valuesAlter variantType ->\n        case variantType of\n            Some value0 value1 value2 value3 ->\n                let\n                    ( alteredValue0, ( alteredValue1, ( alteredValue2, alteredValue3 ) ) ) =\n                        ( value0, ( value1, ( value2, value3 ) ) ) |> valuesAlter\n                in\n                Some alteredValue0 alteredValue1 alteredValue2 alteredValue3\n\n            other ->\n                other\n\n","type":"{ name : String.String, values : List.List Elm.CodeGen.TypeAnnotation, valuesCombined : VariantHelper.GenerateUsed.ValuesCombined } -> { access : Elm.CodeGen.Expression, alter : Elm.CodeGen.Expression, typeValues : Elm.CodeGen.TypeAnnotation }"},{"name":"variantOnly","comment":" Helpers for values of a given only variant.\n\nfor\n\n    type Id attachment\n        = Id (List Int) attachment\n\n\n#### `access`\n\n    \\(Id value0 value1) -> ( value0, value1 )\n\n\n#### `alter`\n\n    \\valuesAlter (Id value0 value1) ->\n        let\n            ( alteredValue0, alteredValue1 ) =\n                ( value0, value1 ) |> valuesAlter\n        in\n        Id alteredValue0 alteredValue1\n\n","type":"{ name : String.String, values : List.List Elm.CodeGen.TypeAnnotation, valuesCombined : VariantHelper.GenerateUsed.ValuesCombined } -> { access : Elm.CodeGen.Expression, alter : Elm.CodeGen.Expression, typeValues : Elm.CodeGen.TypeAnnotation }"},{"name":"variantPattern","comment":" Pattern on a given variant to use with a custom implementation.\n\nfor\n\n    type Data a b c d\n        = Some a b c d\n        | None\n\ngenerates\n\n    Some value0 value1 value2 value3\n\n","type":"{ name : String.String, values : List.List Elm.CodeGen.TypeAnnotation } -> Elm.CodeGen.Pattern"}],"binops":[]}]